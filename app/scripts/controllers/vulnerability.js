'use strict';

angular.module('quitoClimateStudyApp')
  .controller('VulnerabilityCtrl', ['$scope', '$routeParams', '$http', 'Vulnerabilidad', 'leafletData', 'Legend', function ($scope, $routeParams, $http, Vulnerabilidad, leafletData, Legend) {
  	$scope.setPercentHeight = true;

  	//get routing parameters for use with vulnerability service
  	$scope.vulnerabilityName = $routeParams.vulnerability.split('&')[0];
  	$scope.questionName = $routeParams.vulnerability.split('&')[1];      

    //legendElement in global controller scope
    var legendControl; 

  	//default active layers for a vulnerability and question are static and set in the
  	//vulnerability service data source
  	$scope.question = Vulnerabilidad.getQuestionByName($scope.vulnerabilityName, $scope.questionName)
  	$scope.currentRasters = {};
  	$scope.currentVectors = {};    
    $scope.currentLayers = [];    
    $scope.sliderOptions = {
      from: 0,
      to: 1,
      step: 0.01,
      dimension: " %"
    };
  	angular.extend($scope, {
  	center: {
  			//useful defaults for quito, ecuador
  			lat: -0.271,
  			lng: -78.532,
  			zoom: 8
  		}
  	});

  	//public functions
  	$scope.select = function(layer){  		  		
  		updateMap(layer);	
  	};

    $scope.getDownloadLink = function(layer) {
      if (_.isEqual(layer.type, 'vector')){
        return 'vector/' + layer.data + '.csv';
      } else {
        return 'raster/' + layer.data + '.tif';
      }
    };

    $scope.getPopOver = function(layer) {
      // return '<input ng-model="layer.opacity" type="range" min="0" max="1" step="0.1" width="100px">'
      return '<input ng-model="layer.opacity" type="range" min="0" max="1" step="0.1" class="pull-right menuOption">';
      // return layer.name;
    };

    $scope.myOpacity = function(layer) {
      return layer.opacity;
    };
    
    //private functions
  	var updateMap = function(layer) {
  		if (_.isEqual(layer.isSelected, true)){
  			if (_.isEqual(layer.type, 'vector')){
  				addGeoJsonAsVector(layer);
  			} else {
  				addTilesAsRaster(layer);
  			}
  		} else {
  			if (_.isEqual(layer.type, 'vector')){
  				console.log(layer);
				removeVectorLayerFromMap(layer);
  			} else {
				removeRasterLayerFromMap(layer);	
  			}  			
  		} 
  	};

  	var removeVectorLayerFromMap = function(layer){  		
  		var il = $scope.currentVectors[layer.data];
  		console.log(il);
  		leafletData.getMap().then(function(map){						
  			map.removeLayer(il);
  			delete $scope.currentVectors[layer.data];
        legendControl.update(layer, false);
  		});		
  	};

  	
  	var removeRasterLayerFromMap = function (layer) {		
  		var il = $scope.currentRasters[layer.data];
  		leafletData.getMap().then(function(map){
  			map.removeLayer(il);  					
  			delete $scope.currentRasters[layer.data];		 		
        legendControl.update(layer, false);
  		});		
  	};

  	var addGeoJsonAsVector = function(lyr) {
  		$http.get(Vulnerabilidad.getPathOfVector(lyr.data)).success(function(result){ 
  			var ilayer = L.geoJson(result, {
  				style: function(feature){                        
            if (!_.isUndefined(feature.properties['quito-color'])) {              
              if (!_.isUndefined(lyr.isOutlined) && !_.isNull(lyr.isOutlined) && _.isEqual(lyr.isOutlined, true)){
                return {
                  fillColor: feature.properties['quito-color'],
                  color: '#000000',
                  opacity: 1,
                  fillOpacity: $scope.myOpacity(lyr),
                  weight: 3
                };
              } else {
                return {
                  fillColor: feature.properties['quito-color'],
                  color: feature.properties['quito-color'],
                  opacity: 1,
                  fillOpacity: $scope.myOpacity(lyr),
                  weight: 3
                };
              }              
            }            
            else if (!_.isUndefined(feature.properties['quito-color-outline'])){              
              return {                
                  color: feature.properties['quito-color-outline'],
                  opacity: 1,
                  fillOpacity: 0,                  
                  weight: 3
                };
            }
            else {
              return {                
                color: '#000000',
                opacity: $scope.myOpacity(lyr),
                fillOpacity: 0,
                weight: 3
              };
            }
  				},
  				onEachFeature: function(feature, layer) {
  					layer.bindPopup(htmlTableOfJsonObj(feature.properties));
  				},
          pointToLayer: function(feature, latlng){
            if (!_.isUndefined(feature.properties['quito-color'])) {              
              return new L.CircleMarker(latlng, {radius: 3, fillOpacity: 1, fill: true, color: feature.properties['quito-color'], fillColor: feature.properties['quito-color']});
            }            
            else if (!_.isUndefined(feature.properties['quito-color-outline'])){              
              return new L.CircleMarker(latlng, {radius: 3, fillOpacity: 1, fill: true, color: feature.properties['quito-color'], fillColor: feature.properties['quito-color-outline']});
            }
            else {
              console.log(feature.properties);
              return new L.CircleMarker(latlng, {radius: 3, fillOpacity: 1, fill: true, color: '#000000', fillColor: '#000000'});
            }            
          }
  			});
  			$scope.currentVectors[lyr.data] = ilayer;
  			console.log('adding ' + lyr.data + ' as vector');
  			leafletData.getMap().then(function(map) {
  				ilayer.addTo(map);
          legendControl.update(lyr, true);
  			});  			        
  		});  		
  	};

    var initializeLegendControl = function(map) {
      legendControl = L.control({position: 'topright'})  

      legendControl.onAdd = function(map){
        this._div = L.DomUtil.create('div', 'info legend');                
        return this._div;        
      };
      legendControl.update = function(layer, isAdded){
        if (isAdded){
          $scope.currentLayers.push(layer);
        }
        else {
          $scope.currentLayers = _.filter($scope.currentLayers, function(lyr){
            return !_.isEqual(layer, lyr);
          });
        }        
        this._div.innerHTML = generateLegendHtml();
      };

      legendControl.addTo(map);
    };  

    var generateLegendHtml = function(){
      // var div = '<h4>Legend</h4>';      
      var div = '<div class="legendContainer">';
      _.each($scope.currentLayers, function(lyr) {
        div += Legend.GetLegendHTMLOfLayer(lyr.name, lyr.data, _.isEqual(lyr.type, 'raster'));
      });
      div += '</div>';
            
      return div;
    };

  	var addTilesAsRaster = function(lyr) {  
	  	var options = {
            minZoom: 7,
            maxZoom: 12,
            opacity: 1.0,
            tms: false
        };		
		
      var ilayer = L.tileLayer('/raster/' + lyr.data + '/{z}/{x}/{y}.png', options);
  		
      $scope.currentRasters[lyr.data] = ilayer;
  		leafletData.getMap().then(function(map) {
  			console.log('adding ' + lyr.data + ' as raster');
  			ilayer.addTo(map);
        legendControl.update(lyr, true);
  		});      
  	};

  	var initializeDefaultLayers = function() {
      leafletData.getMap().then(function(map) {
        initializeLegendControl(map);        
        L.control.scale({position: 'bottomleft'}).addTo(map);
        var selectedLayers = getSelectedLayers();      
        _.each(_.filter(selectedLayers, function(lyr) {return lyr.type === 'raster'; }), function (lyr) {
            if (_.isUndefined($scope.currentRasters[lyr.data])){          
            addTilesAsRaster(lyr);        
          }
        });     
        _.each(_.filter(selectedLayers, function(lyr) {return lyr.type === 'vector'; }), function (lyr) {
            if (_.isUndefined($scope.currentVectors[lyr.data])){          
            addGeoJsonAsVector(lyr);        
          }
        });        
      });       	
  	};

  	//generate popup html table from generic properties dictionary of layer obj
  	var htmlTableOfJsonObj = function(json) {
  		var tbl = [];
  		tbl.push('<table>');
  		// tbl.append('<caption>' + tableName + '</caption>');
  		
  		//header row
  		tbl.push('<thead><tr>');
  		tbl.push('<th>Código</th>')
  		tbl.push('<th>Valor</th>')		
      // tbl.push('<th>Explicación</th>')
  		tbl.push('</tr></thead>');
  		
  		//body
  		tbl.push('<tbody>');
  		_.each(json, function(value, key, list){			
  			if (!_.isEqual(key, 'quito-color') && !_.isEqual(key, 'quito-color-outline')){
  				tbl.push('<tr><th>' + key + ': </th><td>' + value + '</td></tr>');
  			}	
  		});
  		tbl.push('</tbody></table>');
  		return tbl.join("");
  	};

  	var getSelectedLayers = function(){  		
  		var selectedLayers = [];
      _.each($scope.question.categories, function(category) {
        _.each(category.sections, function(section){
          selectedLayers.push(getSelectedLayersOfSection(section));
        });        
      });  		
  		
  		return _.flatten(selectedLayers);
  	};

  	var getSelectedLayersOfSection = function(section){
  		return _.filter(section.layers, function(lyr) {
  			return lyr.isSelected === true;
  		});
  	};

  	//initialization
  	initializeDefaultLayers();  	    
  }]);
