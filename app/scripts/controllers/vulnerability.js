'use strict';

angular.module('quitoClimateStudyApp')
  .controller('VulnerabilityCtrl', ['$scope', '$routeParams', '$http', 'Vulnerabilidad', 'leafletData', function ($scope, $routeParams, $http, Vulnerabilidad, leafletData) {
  	
  	//get routing parameters for use with vulnerability service
  	$scope.vulnerabilityName = $routeParams.vulnerability.split('&')[0];
  	$scope.questionName = $routeParams.vulnerability.split('&')[1];

  	//default active layers for a vulnerability and question are static and set in the
  	//vulnerability service data source
  	$scope.question = Vulnerabilidad.getQuestionByName($scope.vulnerabilityName, $scope.questionName)
  	$scope.currentRasters = {};
  	$scope.currentVectors = {};    

  	angular.extend($scope, {
  		center: {
  			//useful defaults for quito, ecuador
  			lat: -0.271,
  			lng: -78.532,
  			zoom: 8
  		}
  	});

  	//public functions
  	$scope.select = function(layer){  		  		
  		updateMap(layer);	
  	};

    $scope.getDownloadLink = function(layer) {
      if (_.isEqual(layer.type, 'vector')){
        return 'vector/' + layer.data + '.csv';
      } else {
        return 'raster/' + layer.data + '.tif';
      }
    };

  	var updateMap = function(layer) {
  		if (_.isEqual(layer.isSelected, true)){
  			if (_.isEqual(layer.type, 'vector')){
  				addGeoJsonAsVector(layer);
  			} else {
  				addTilesAsRaster(layer);
  			}
  		} else {
  			if (_.isEqual(layer.type, 'vector')){
  				console.log(layer);
				removeVectorLayerFromMap(layer);
  			} else {
				removeRasterLayerFromMap(layer);	
  			}  			
  		} 
  	};

  	var removeVectorLayerFromMap = function(layer){  		
  		var il = $scope.currentVectors[layer.data];
  		console.log(il);
  		leafletData.getMap().then(function(map){						
  			map.removeLayer(il);
  			delete $scope.currentVectors[layer.data];
  		});		
  	};

  	//private functions
  	var removeRasterLayerFromMap = function (layer) {		
  		var il = $scope.currentRasters[layer.data];
  		leafletData.getMap().then(function(map){
  			map.removeLayer(il);  					
  			delete $scope.currentRasters[layer.data];		 		
  		});		
  	};

  	var addGeoJsonAsVector = function(lyr) {
  		$http.get(Vulnerabilidad.getPathOfVector(lyr.data)).success(function(result){ 
  			var ilayer = L.geoJson(result, {
  				style: function(feature){            
            if (!_.isUndefined(feature.properties['quito-color'])) {
              return {
                fillColor: feature.properties['quito-color'],
                color: feature.properties['quito-color'],
                opacity: 1,
                fillOpacity: 1,
                weight: 3
              };
            }
            else {
              return {                
                color: '#000000',
                opacity: 1,
                fillOpacity: 0,
                weight: 3
              };
            }
  				},
  				onEachFeature: function(feature, layer) {
  					layer.bindPopup(htmlTableOfJsonObj(feature.properties));
  				}
  			});
  			$scope.currentVectors[lyr.data] = ilayer;
  			console.log('adding ' + lyr.data + ' as vector');
  			leafletData.getMap().then(function(map) {
  				ilayer.addTo(map);
  			});  			
  		});  		
  	};

  	var addTilesAsRaster = function(lyr) {  
	  	var options = {
            minZoom: 7,
            maxZoom: 12,
            opacity: 1.0,
            tms: false
        };		
		var ilayer = L.tileLayer('/raster/' + lyr.data + '/{z}/{x}/{y}.png', options);
		$scope.currentRasters[lyr.data] = ilayer;
		leafletData.getMap().then(function(map) {
			console.log('adding ' + lyr.data + ' as raster');
			ilayer.addTo(map);
		});
  	};

  	var initializeDefaultLayers = function() {
  		var selectedLayers = getSelectedLayers();
  		_.each(_.filter(selectedLayers, function(lyr) {return lyr.type === 'vector'; }), function (lyr) {
  			if (_.isUndefined($scope.currentVectors[lyr.data])){					
				addGeoJsonAsVector(lyr);				
			}
		});  
		_.each(_.filter(selectedLayers, function(lyr) {return lyr.type === 'raster'; }), function (lyr) {
  			if (_.isUndefined($scope.currentRasters[lyr.data])){					
				addTilesAsRaster(lyr);				
			}
		});  		


  		/*leafletData.getMap().then(function(map) {
  			_.each(_.filter(selectedLayers, function(lyr) {return lyr.type === 'vector'; }), function (lyr) {
  				$http.get(Vulnerabilidad.getPathOfVector(lyr.data)).success(function(result){
  					_.each(result, function(r) { // console.log(r); });
	  					L.geoJson(result, {
	  						style: function(feature){
	  							return {color: feature.properties['quito-color'] };
	  						},
	  						onEachFeature: function(feature, layer) {
	  							layer.bindPopup(htmlTableOfJsonObj(feature.properties));
	  						}
	  					}).addTo(map);  				
	  				});
  				});
  			});  			
  		});*/
  	};

  	//generate popup html table from generic properties dictionary of layer obj
  	var htmlTableOfJsonObj = function(json) {
		var tbl = [];
		tbl.push('<table>');
		// tbl.append('<caption>' + tableName + '</caption>');
		
		//header row
		tbl.push('<thead><tr>');
		tbl.push('<th>Código</th>')
		tbl.push('<th>Valor</th>')		
    // tbl.push('<th>Explicación</th>')
		tbl.push('</tr></thead>');
		
		//body
		tbl.push('<tbody>');
		_.each(json, function(value, key, list){			
			if (!_.isEqual(key, 'quito-color')){
				tbl.push('<tr><th>' + key + ': </th><td>' + value + '</td></tr>');
			}	
		});
		tbl.push('</tbody></table>');
		return tbl.join("");
  	};

  	var getSelectedLayers = function(){  		
  		var selectedLayers = [];
  		_.each($scope.question.base, function(section) { 
  			selectedLayers.push(getSelectedLayersOfSection(section));
  		});
  		_.each($scope.question.exposures, function(section) { 
  			selectedLayers.push(getSelectedLayersOfSection(section));
  		});
  		_.each($scope.question.sensitivityAnalysis, function(section) { 
  			selectedLayers.push(getSelectedLayersOfSection(section));
  		});
  		_.each($scope.question.vulnerability2050, function(section) { 
  			selectedLayers.push(getSelectedLayersOfSection(section));
  		});
  		
  		return _.flatten(selectedLayers);
  	};

  	var getSelectedLayersOfSection = function(section){
  		return _.filter(section.layers, function(lyr) {
  			return lyr.isSelected === true;
  		});
  	};

  	//initialization
  	initializeDefaultLayers();  	
  }]);
